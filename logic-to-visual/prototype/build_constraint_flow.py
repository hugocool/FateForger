"""
One-time build script: produces a fully self-contained constraint_flow.html.

Run once:  python docs/build_constraint_flow.py
Output:    docs/constraint_flow.html   (open directly in any browser, no server needed)
"""

import base64
import json
from pathlib import Path

HERE = Path(__file__).parent

# â”€â”€ load pre-rendered SVG (generated by `d2 constraint_flow.d2 constraint_flow.svg`) â”€â”€
svg_raw = (HERE / "constraint_flow.svg").read_text(encoding="utf-8")
svg_raw = svg_raw.replace('<?xml version="1.0" encoding="utf-8"?>', "").strip()
# Leave the SVG attributes intact â€” sizing is handled fully in JS

# â”€â”€ load svg-pan-zoom (download once with: curl -fsSL https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js -o docs/svg-pan-zoom.min.js) â”€â”€
panzoom_js = (HERE / "svg-pan-zoom.min.js").read_text(encoding="utf-8")

# â”€â”€ verify D2-generated base64 class names match our node IDs â”€â”€
# D2 encodes node IDs as base64 for class names.
NODE_IDS = [
    # leaf nodes (container-qualified)
    "extraction.slack",
    "extraction.llm_agent",
    "extraction.notion_extractor",
    "stores.notion_db",
    "stores.sqlite_db",
    "prefetch.date_commit",
    "prefetch.retriever",
    "prefetch.query_plan",
    "prefetch.type_ids",
    "prefetch.mcp_server",
    "filters.notion_store",
    "filters.filter_row.date_filter",
    "filters.filter_row.scope_filter",
    "filters.filter_row.status_filter",
    "filters.filter_row.stage_filter",
    "filters.filter_row.event_filter",
    "filters.startup_tag",
    "postprocess.dedup",
    "postprocess.suppress",
    "postprocess.dow",
    "collect",
    "active",
    # phase containers
    "extraction",
    "stores",
    "prefetch",
    "filters",
    "filters.filter_row",
    "postprocess",
]

# Verify all IDs are present in the rendered SVG
missing = [
    nid for nid in NODE_IDS if base64.b64encode(nid.encode()).decode() not in svg_raw
]
if missing:
    print(f"WARNING: {len(missing)} node IDs not found in SVG: {missing}")
else:
    print("All node classes verified âœ“")

# â”€â”€ step data â”€â”€
STEPS = [
    {
        "tag": "Overview",
        "title": "Constraint Collection Flow",
        "nodes": [],
        "body": """
<p>The full lifecycle of how the timeboxing agent discovers, stores, and applies
scheduling preferences. Use the steps on the left to walk through each part.</p>
<ul class="fact-list">
  <li><b>Phase 1 â€” Blue</b> â€” live extraction from the Slack conversation</li>
  <li><b>Stores â€” Yellow/Green</b> â€” Notion DB (durable) and SQLite (session-scoped)</li>
  <li><b>Phase 2 â€” Purple</b> â€” background prefetch triggered at date commit</li>
  <li><b>Phase 3 â€” Orange</b> â€” Notion query with server-side filters</li>
  <li><b>Phase 4 â€” Green</b> â€” post-retrieval dedup, suppression, metadata</li>
  <li><b>Red</b> â€” final merge into <code>session.active_constraints</code></li>
</ul>
<div class="callout info">Use â† â†’ arrow keys to step through, or click the sidebar buttons.</div>
""",
    },
    {
        "tag": "Step 1 of 8",
        "title": "The two constraint stores",
        "nodes": ["stores", "stores.notion_db", "stores.sqlite_db"],
        "body": """
<p>There are <b>two separate stores</b>, each with a different role.</p>
<ul class="fact-list">
  <li><b>Notion (TB Constraints DB)</b> â€” durable, cross-session memory. Lives forever.
      Stores preferences like "no meetings before 9am."</li>
  <li><b>SQLite (Session Store)</b> â€” session-scoped scratch space, only for the current
      Slack thread. Stores constraints extracted live, proposed but not yet locked.</li>
</ul>
<div class="callout info">Notion is the source of truth for preferences. SQLite is the
fast local cache and current-session workspace. <code>_collect_constraints()</code> merges both.</div>
""",
    },
    {
        "tag": "Step 2 of 8",
        "title": "Live extraction from Slack",
        "nodes": [
            "extraction",
            "extraction.slack",
            "extraction.llm_agent",
            "extraction.notion_extractor",
        ],
        "body": """
<p>Every time the user sends a message, an <b>LLM constraint agent</b> runs in the background.</p>
<ul class="fact-list">
  <li>The LLM reads the conversation and extracts scheduling preferences the user stated</li>
  <li>E.g. <em>"I want to exercise in the morning"</em>, <em>"no calls after 5pm"</em></li>
  <li>The extractor writes new constraints to <b>Notion</b>, deduped by UID</li>
  <li>A session copy also goes to <b>SQLite</b> so the Slack UI can display them immediately</li>
</ul>
<div class="callout">The LLM is told: never extract generic timeboxing definitions â€” only
concrete, user-stated preferences.</div>
""",
    },
    {
        "tag": "Step 3 of 8",
        "title": "The prefetch trigger",
        "nodes": ["prefetch", "prefetch.date_commit", "prefetch.retriever"],
        "body": """
<p>The durable prefetch is a <b>background task</b> fired as soon as the user commits
to a planning date (Stage 0).</p>
<ul class="fact-list">
  <li><code>_queue_durable_constraint_prefetch()</code> is called on date commit</li>
  <li>It runs in the background â€” the user is not blocked</li>
  <li>The agent awaits it (with a 20s timeout) before entering Stage 1</li>
  <li>Keyed by <code>user_id:thread_ts:planned_date</code> to deduplicate concurrent calls</li>
</ul>
<div class="callout info">This non-blocking pattern means Notion's network latency
doesn't delay the user's first response.</div>
""",
    },
    {
        "tag": "Step 4 of 8",
        "title": "Building the query plan",
        "nodes": [
            "prefetch",
            "prefetch.query_plan",
            "prefetch.type_ids",
            "prefetch.mcp_server",
        ],
        "body": """
<p><b>ConstraintRetriever</b> builds a deterministic query plan from the current
planning context â€” no LLM involved.</p>
<ul class="fact-list">
  <li>Derives which <b>event types</b> to request: immovables â†’ M, sleep â†’ R,
      commutes â†’ C, habits â†’ H, gaps â†’ BU/BG</li>
  <li>For stages beyond COLLECT, calls <code>query_types()</code> to get ranked
      type_ids from Notion first</li>
  <li>For Stage 1 (COLLECT), type_id lookup is skipped entirely â€” avoids extra
      RPCs on the critical path</li>
</ul>
<div class="callout">Gap-driven, not NLU. The retriever never interprets free-form text.</div>
""",
    },
    {
        "tag": "Step 5 of 8",
        "title": "Server-side Notion filters",
        "nodes": [
            "filters",
            "filters.notion_store",
            "filters.filter_row",
            "filters.filter_row.date_filter",
            "filters.filter_row.scope_filter",
            "filters.filter_row.status_filter",
            "filters.filter_row.stage_filter",
            "filters.filter_row.event_filter",
        ],
        "body": """
<p><code>NotionConstraintStore.query_constraints()</code> applies several filters
<b>in Notion</b> before any records come back.</p>
<ul class="fact-list">
  <li><b>Date range</b>: <code>start_date â‰¤ today â‰¤ end_date</code> â€” empty fields mean
      unbounded (the constraint always applies)</li>
  <li><b>Scope</b>: <code>profile</code> always applies; <code>datespan</code> is
      date-bounded; session-scoped stays in SQLite</li>
  <li><b>Status</b>: only <code>locked</code> and <code>proposed</code> â€” declined excluded</li>
  <li><b>Applies Stages</b>: each constraint declares which stages it is relevant to</li>
  <li><b>Event Types</b>: each constraint declares which event types it governs (M, DW, SW, H, Râ€¦)</li>
</ul>
""",
    },
    {
        "tag": "Step 6 of 8",
        "title": "The startup_prefetch special case",
        "nodes": ["filters", "filters.startup_tag"],
        "body": """
<p>Stage 1 (COLLECT_CONSTRAINTS) gets a special <b>first-pass query</b> before the main one.</p>
<ul class="fact-list">
  <li>Tag filter <code>startup_prefetch</code> is applied</li>
  <li>Scope is restricted to <code>profile</code> and <code>datespan</code> only</li>
  <li>Pulls the user's always-on preferences <em>before</em> any LLM has seen the session</li>
  <li>If this first pass returns results, those are returned and the main query is skipped</li>
</ul>
<div class="callout">Goal: load the most important "always applies" constraints onto the
LLM's context as fast as possible, using a deterministic tag rather than a semantic search.</div>
""",
    },
    {
        "tag": "Step 7 of 8",
        "title": "Post-retrieval processing",
        "nodes": [
            "postprocess",
            "postprocess.dedup",
            "postprocess.suppress",
            "postprocess.dow",
        ],
        "body": """
<p>After records come back from Notion, three things happen client-side.</p>
<ul class="fact-list">
  <li><b>Deduplicate by UID</b>: startup pass + main pass may return the same record;
      first-seen wins</li>
  <li><b>Filter suppressed UIDs</b>: if the user declined a constraint this session,
      it's excluded even if Notion still has it as <em>proposed</em></li>
  <li><b>days_of_week metadata</b>: the <code>days_of_week</code> field (MOâ€“SU) is
      <em>not</em> filtered server-side â€” it's surfaced as metadata to the planning
      LLM, which must respect it when filling the skeleton</li>
</ul>
<div class="callout info">Weekend/holiday constraints are modelled as
<code>scope=datespan</code> with explicit date bounds, or as
<code>days_of_week=[SA,SU]</code> constraints the LLM reasons about.</div>
""",
    },
    {
        "tag": "Step 8 of 8",
        "title": "Merge into active_constraints",
        "nodes": ["collect", "active", "stores.sqlite_db"],
        "body": """
<p><code>_collect_constraints()</code> is the final assembly point, called at the
start of every stage.</p>
<ul class="fact-list">
  <li>Reads <b>durable constraints by stage</b> from
      <code>session.durable_constraints_by_stage</code> (populated by the prefetch)</li>
  <li>Reads <b>session-local constraints</b> from SQLite for the current thread</li>
  <li>Deduplicates the combined list and removes any with <code>status=DECLINED</code></li>
  <li>Result stored on <code>session.active_constraints</code> and injected into every
      subsequent LLM planning prompt</li>
</ul>
<div class="callout">Every stage gate, skeleton draft, refine, and review call starts
from this same merged list â€” one consistent view of constraints throughout the session.</div>
""",
    },
]

import json

steps_json = json.dumps(STEPS, ensure_ascii=False)
nodes_json = json.dumps(NODE_IDS, ensure_ascii=False)

# â”€â”€ Per-node detail panel content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DETAIL_PANELS = {
    "stores": """
<div class="dp-header"><span class="dp-icon">ğŸ—„</span> Constraint Stores â€” Overview</div>
<p>Two stores, two roles. Notion is the durable cross-session source of truth; SQLite is the fast session-scoped workspace written to immediately on extraction so the Slack UI can display constraints without waiting for Notion round-trips.</p>
<table class="er-table"><thead><tr><th>Store</th><th>Scope</th><th>Survives session?</th><th>Written by</th></tr></thead>
<tbody>
  <tr><td class="pk">Notion TB Constraints DB</td><td>profile / datespan</td><td>âœ… Yes</td><td>NotionConstraintExtractor (via MCP upsert)</td></tr>
  <tr><td class="pk">SQLite timeboxing_constraints</td><td>session (thread_ts)</td><td>âŒ No</td><td>ConstraintStore.add_constraints() immediately on extraction</td></tr>
</tbody></table>
<p style="margin-top:8px">At each stage boundary, <code>_collect_constraints()</code> merges both stores, deduplicates by UID, removes DECLINED records, and caches the result on <code>session.active_constraints</code>.</p>
<p>Click <b>stores.notion_db</b> or <b>stores.sqlite_db</b> individually for full schemas.</p>
""",
    "stores.notion_db": """
<div class="dp-header"><span class="dp-icon">ğŸ“‹</span> Notion â€” TB Constraints DB Schema</div>
<p style="margin-bottom:8px">Populated by <code>_queue_durable_prefetch_stage()</code> â†’ stored in <code>session.durable_constraints_by_stage[stage]</code>. On a date change, the entire dict is reset and re-fetched.</p>
<table class="er-table">
<thead><tr><th>Field</th><th>Type</th><th>Notes</th></tr></thead>
<tbody>
<tr><td class="pk">uid</td><td>Title</td><td>Idempotency key â€” e.g. <code>user:no-calls-after-5pm</code>. Upsert key.</td></tr>
<tr><td>name</td><td>Rich Text</td><td>Short human-scannable label</td></tr>
<tr><td>description</td><td>Rich Text</td><td>One-sentence operational meaning</td></tr>
<tr><td>necessity</td><td>Select</td><td><code>must</code> | <code>should</code></td></tr>
<tr><td>status</td><td>Select</td><td><code>proposed</code> | <code>locked</code> | <code>declined</code></td></tr>
<tr><td>scope</td><td>Select</td><td><code>profile</code> = always applies Â· <code>datespan</code> = date-bounded Â· <code>session</code> = SQLite only</td></tr>
<tr><td>source</td><td>Select</td><td><code>user</code> | <code>calendar</code> | <code>system</code> | <code>feedback</code></td></tr>
<tr><td>start_date / end_date</td><td>Date</td><td>Null = unbounded. Server-side filter: <code>start â‰¤ today â‰¤ end</code>.</td></tr>
<tr><td>applies_stages</td><td>Multi-select</td><td>CollectConstraints Â· CaptureInputs Â· Skeleton Â· Refine Â· ReviewCommit</td></tr>
<tr><td>applies_event_types</td><td>Multi-select</td><td>M Â· C Â· DW Â· SW Â· H Â· R Â· BU Â· BG Â· PR</td></tr>
<tr><td>days_of_week</td><td>Multi-select</td><td>MOâ€“SU. <em>Not filtered server-side</em> â€” surfaced as metadata to the planning LLM.</td></tr>
<tr><td>tags</td><td>Multi-select</td><td>Routing tags, e.g. <code>startup_prefetch</code></td></tr>
<tr><td>payload</td><td>JSON (Text)</td><td><code>rule_kind</code> Â· <code>windows[]</code> Â· <code>scalar_params</code></td></tr>
<tr><td>topics</td><td>Multi-select</td><td>Routing/grouping tags assigned by the extractor agent</td></tr>
</tbody></table>
<div class="dp-file">src/fateforger/adapters/notion/timeboxing_preferences.py</div>
""",
    "stores.sqlite_db": """
<div class="dp-header"><span class="dp-icon">ğŸ—„</span> SQLite â€” <code>timeboxing_constraints</code></div>
<p>Session-scoped store. Written immediately on extraction so the Slack UI can display constraints without waiting for Notion.</p>
<p style="margin-bottom:8px">Also receives a mirrored copy of durable constraints via <code>_sync_durable_constraints_to_store()</code> after the prefetch completes â€” this lets the Slack UI show all active constraints in one place without separate Notion queries.</p>
<table class="er-table">
<thead><tr><th>Column</th><th>Type</th><th>Notes</th></tr></thead>
<tbody>
<tr><td class="pk">id</td><td>Integer PK</td><td>Auto-increment</td></tr>
<tr><td>user_id</td><td>String</td><td>Slack user ID</td></tr>
<tr><td>channel_id / thread_ts</td><td>String?</td><td>Session key â€” queries always filter by <code>thread_ts</code></td></tr>
<tr><td>name / description</td><td>String</td><td></td></tr>
<tr><td>necessity</td><td>Enum</td><td><code>must</code> | <code>should</code></td></tr>
<tr><td>status</td><td>Enum</td><td><code>proposed</code> | <code>locked</code> | <code>declined</code></td></tr>
<tr><td>scope</td><td>Enum</td><td><code>session</code> | <code>profile</code> | <code>datespan</code></td></tr>
<tr><td>source</td><td>Enum</td><td><code>user</code> | <code>calendar</code> | <code>system</code> | <code>feedback</code></td></tr>
<tr><td>confidence</td><td>Float 0â€“1</td><td>LLM confidence score on extraction</td></tr>
<tr><td>start_date / end_date</td><td>Date?</td><td>Optional date bounds</td></tr>
<tr><td>days_of_week</td><td>JSON</td><td>e.g. <code>["SA", "SU"]</code></td></tr>
<tr><td>tags / hints / selector</td><td>JSON</td><td>Routing metadata + event-type selector</td></tr>
<tr><td>supersedes</td><td>JSON</td><td>List of UIDs this overrides</td></tr>
<tr><td>created_at / updated_at</td><td>DateTime</td><td>Auto-managed by SQLAlchemy</td></tr>
</tbody></table>
<div class="dp-code"># Queried by _collect_constraints():
await store.list_constraints(
    user_id=session.user_id,
    channel_id=session.channel_id,
    thread_ts=session.thread_ts,
)</div>
<div class="dp-file">src/fateforger/agents/timeboxing/preferences.py â€” class Constraint(ConstraintBase, table=True)</div>
""",
    "extraction": """
<div class="dp-header"><span class="dp-icon">ğŸ”µ</span> Phase 1 â€” Live Extraction Pipeline</div>
<p>Every Slack message fires a concurrent background extraction. The user is never blocked â€” the main response is sent immediately while extraction runs in the background.</p>
<div class="dp-flow">
  <div class="dp-flow-step">ğŸ’¬ Message arrives â†’ <code>_queue_constraint_extraction(session, user_message)</code></div>
  <div class="dp-flow-arrow">â†“ dedup by <code>user_id:thread_ts:hash(message)</code></div>
  <div class="dp-flow-step">Async task: LLM reads conversation â†’ outputs <code>ConstraintBatch</code></div>
  <div class="dp-flow-arrow">â†“ parallel writes</div>
  <div class="dp-flow-step">â‘  SQLite write (immediate display) â€” via <code>ConstraintStore.add_constraints()</code></div>
  <div class="dp-flow-step">â‘¡ Notion upsert (durable) â€” via <code>_queue_durable_constraint_upsert()</code></div>
  <div class="dp-flow-arrow">â†“ on task complete</div>
  <div class="dp-flow-step"><code>pending_constraint_extractions.discard(task_key)</code></div>
  <div class="dp-flow-step"><code>_collect_constraints(session)</code> â€” refresh <code>active_constraints</code></div>
</div>
<p style="margin-top:8px"><b>At stage boundaries</b> (e.g. entering Stage 1), <code>_await_pending_constraint_extractions()</code> waits for all in-flight extraction tasks before the stage gating LLM runs â€” so the gate always sees all extracted constraints.</p>
<div class="dp-file">src/fateforger/agents/timeboxing/agent.py â€” _queue_constraint_extraction()</div>
""",
    "extraction.slack": """
<div class="dp-header"><span class="dp-icon">ğŸ’¬</span> Slack Thread â€” How Extraction Is Triggered</div>
<p>Incoming Slack messages are routed via <code>handlers.py</code> as <code>TimeboxingUserReply</code> messages. On every user reply, the session node calls <code>_queue_constraint_extraction()</code> before processing the main timeboxing flow.</p>
<div class="dp-code"># In the session message-handling node:
self._orchestrator._queue_constraint_extraction(
    session, user_message=msg.text
)
# â†’ doesn't block; launches background asyncio task
# â†’ task_key = f"{user_id}:{thread_ts}:{hash(text)}"
# â†’ deduplicated: same message won't spawn two tasks</div>
<p>The <code>pending_constraint_extractions</code> set on the session object tracks all in-flight task keys. Before stage gating runs, the orchestrator awaits all pending tasks (20s timeout per task).</p>
<div class="dp-file">src/fateforger/agents/timeboxing/nodes/nodes.py Â· handlers.py</div>
""",
    "extraction.llm_agent": """
<div class="dp-header"><span class="dp-icon">ğŸ¤–</span> LLM Constraint Agent â€” Prompt + Input</div>
<p><b>Input payload: <code>ConstraintHandoff</code></b></p>
<div class="dp-code">{
  "planned_date": "2026-02-24",
  "timezone": "Europe/Amsterdam",
  "stage_id": "CollectConstraints",
  "user_utterance": "I don't want any meetings before 9am",
  "triggering_suggestion": null,
  "impacted_event_types": ["M"],
  "suggested_tags": ["no-early-meetings"],
  "decision_scope": "profile"
}</div>
<p><b>System prompt key rules:</b></p>
<ul style="font-size:12px;line-height:1.7;margin-left:16px;">
  <li>Default <code>status=proposed</code> unless user explicitly confirms/locks</li>
  <li>Default <code>scope=profile</code> for "usually / I prefer / in general" statements</li>
  <li>Use <code>scope=datespan</code> for "this week / today / on Fridays"</li>
  <li>Use <code>scope=session</code> only for one-off overrides</li>
  <li>Records must be MECE: governance Â· applicability Â· routing Â· rule_payload Â· lifecycle</li>
  <li>If ambiguity remains: conservative defaults + single <code>clarifying_question</code></li>
  <li><b>Never extract</b> generic timeboxing definitions â€” only concrete stated preferences</li>
</ul>
<div class="dp-code">Allowed enums:
- necessity:    must | should
- status:       proposed | locked
- scope:        session | profile | datespan
- rule_kind:    prefer_window | avoid_window | fixed_bedtime
                min_sleep | buffer | sequencing | capacity
- days_of_week: MO | TU | WE | TH | FR | SA | SU
- applies_stages: CollectConstraints | CaptureInputs
                  Skeleton | Refine | ReviewCommit
- applies_event_types: M | C | DW | SW | H | R | BU | BG | PR</div>
<div class="dp-file">src/fateforger/agents/timeboxing/notion_constraint_extractor.py â€” CONSTRAINT_EXTRACTOR_SYSTEM_PROMPT</div>
""",
    "extraction.notion_extractor": """
<div class="dp-header"><span class="dp-icon">ğŸ”—</span> NotionConstraintExtractor â€” Full Flow</div>
<div class="dp-flow">
  <div class="dp-flow-step"><code>extract_and_upsert(handoff: ConstraintHandoff)</code></div>
  <div class="dp-flow-arrow">â†“ AutoGen AssistantAgent (20s timeout)</div>
  <div class="dp-flow-step">1. LLM calls <code>constraint_query_types(stage, event_types)</code> â€” shortlist types</div>
  <div class="dp-flow-step">2. LLM calls <code>constraint_query_constraints(...)</code> â€” check for duplicates</div>
  <div class="dp-flow-step">3. LLM calls <code>constraint_upsert_constraint(record, event)</code> â€” write to Notion</div>
  <div class="dp-flow-arrow">â†“ returns JSON parsed to</div>
  <div class="dp-flow-step"><code>ConstraintExtractionOutput(uid, constraint_record, event_record)</code></div>
</div>
<p><b>On timeout or LLM failure:</b> returns <code>None</code>. The SQLite optimistic write already happened, so the Slack UI still has the constraint â€” only Notion durability is lost until the next extraction attempt.</p>
<p><b>Output is also logged</b> via <code>constraint_log_event()</code> with event type <code>extracted</code>.</p>
<div class="dp-file">src/fateforger/agents/timeboxing/notion_constraint_extractor.py â€” class NotionConstraintExtractor</div>
""",
    "prefetch": """
<div class="dp-header"><span class="dp-icon">ğŸŸ£</span> Phase 2 â€” Background Prefetch</div>
<p>When the user commits to a planning date (Stage 0 / CaptureInputs), <code>_queue_durable_constraint_prefetch()</code> fires an async background task per stage.</p>
<div class="dp-flow">
  <div class="dp-flow-step">Date committed â†’ <code>_queue_durable_constraint_prefetch(user_id, thread_ts, date)</code></div>
  <div class="dp-flow-arrow">â†“ one background task per stage (CollectConstraints + others)</div>
  <div class="dp-flow-step"><code>_queue_durable_prefetch_stage(session, stage, planned_date)</code></div>
  <div class="dp-flow-arrow">â†“ on success</div>
  <div class="dp-flow-step"><code>session.durable_constraints_by_stage[stage] = constraints</code></div>
  <div class="dp-flow-step"><code>_sync_durable_constraints_to_store()</code> â€” mirror to SQLite</div>
  <div class="dp-flow-step"><code>_collect_constraints(session)</code> â€” refresh active set</div>
</div>
<p><b>Date change reset:</b> if the user changes the planning date, <code>durable_constraints_by_stage = {}</code> and all loaded-stage markers are cleared. The prefetch restarts for the new date.</p>
<p><b>Stage-entry wait:</b> <code>_await_pending_durable_constraint_prefetch()</code> waits (20s) before Stage 1 gating so the LLM always sees loaded constraints.</p>
<div class="dp-file">src/fateforger/agents/timeboxing/agent.py</div>
""",
    "prefetch.date_commit": """
<div class="dp-header"><span class="dp-icon">ğŸ“…</span> Stage 0: Date Commit â€” Prefetch Trigger</div>
<p>Stage 0 (<code>CaptureInputs</code>) is when the user settles on the planning date. This event triggers the prefetch <em>and</em> resets any stale prefetch if the date changed.</p>
<div class="dp-code"># If date changed from a previous session:
if session.durable_constraints_date != planned_date:
    session.durable_constraints_by_stage = {}
    session.durable_constraints_loaded_stages = set()
    session.pending_durable_constraints = False
    session.durable_constraints_failed_stages = {}
    session.durable_constraints_date = None

# Then queue fresh prefetch:
_queue_durable_constraint_prefetch(
    session, planned_date=planned_date
)</div>
<p>Deduplication: if <code>durable_constraints_date == planned_date</code> and the stage is already in <code>durable_constraints_loaded_stages</code>, the task is skipped â€” no double-fetch.</p>
""",
    "prefetch.retriever": """
<div class="dp-header"><span class="dp-icon">ğŸ”</span> ConstraintRetriever.retrieve()</div>
<p>Pure deterministic orchestration â€” no LLM involved. Translates the current planning context into a Notion MCP query.</p>
<div class="dp-flow">
  <div class="dp-flow-step">1. <code>_build_query_plan(stage, planned_date, event_types)</code></div>
  <div class="dp-flow-arrow">â†“ if stage â‰  COLLECT_CONSTRAINTS</div>
  <div class="dp-flow-step">2. <code>query_types(stage, event_types)</code> â†’ ranked <code>type_ids[]</code></div>
  <div class="dp-flow-arrow">â†“ always</div>
  <div class="dp-flow-step">3. <code>query_constraints(filters, type_ids, tags)</code> via MCP</div>
  <div class="dp-flow-arrow">â†“ returns</div>
  <div class="dp-flow-step"><code>List[ConstraintRecord]</code> (already server-filtered)</div>
</div>
<p>For Stage 1 (COLLECT_CONSTRAINTS), step 2 is entirely skipped to avoid the extra Notion RPC on the critical path. type_ids are not needed because Stage 1 uses coarse scope + date + status filters only.</p>
<div class="dp-file">src/fateforger/agents/timeboxing/ â€” ConstraintRetriever</div>
""",
    "prefetch.query_plan": """
<div class="dp-header"><span class="dp-icon">ğŸ“</span> Build Query Plan â€” Gap-Driven Event Types</div>
<p>The query plan is derived from the current <b>planning stage</b> and a <b>gap analysis</b> of the skeleton â€” which event types are still unplaced. This is deterministic; no LLM needed.</p>
<table class="er-table">
<thead><tr><th>Gap / context</th><th>Event types requested</th><th>Why</th></tr></thead>
<tbody>
<tr><td>No plan yet / Stage 1</td><td>all types</td><td>Collect all profile defaults</td></tr>
<tr><td>Immovable anchors missing</td><td>M (Meeting)</td><td>Fixed-time commitments</td></tr>
<tr><td>Sleep anchor missing</td><td>R (Rest)</td><td>Bedtime / wake constraints</td></tr>
<tr><td>Commute missing</td><td>C (Commute)</td><td>Transit time constraints</td></tr>
<tr><td>Daily habits</td><td>H (Habit)</td><td>Recurring rituals</td></tr>
<tr><td>Focus blocks missing</td><td>DW, SW</td><td>Deep / Shallow Work windows</td></tr>
<tr><td>Buffer gaps</td><td>BU, BG</td><td>Unstructured / general buffers</td></tr>
</tbody></table>
<p style="margin-top:6px">The plan is pure Python logic â€” no LLM call. This keeps the critical path deterministic and fast.</p>
""",
    "prefetch.type_ids": """
<div class="dp-header"><span class="dp-icon">ğŸ·</span> query_types() â€” Type ID Lookup</div>
<p>Skipped entirely at Stage 1 (COLLECT_CONSTRAINTS) to avoid extra RPCs. Used at Skeleton/Refine/ReviewCommit to get ranked type IDs from the Notion constraint-type catalog, which allows more targeted queries.</p>
<div class="dp-code">constraint_query_types(
  stage="Skeleton",
  event_types=["M", "DW", "SW"]
)
# â†’ [type_id_1, type_id_2, ...]
# These are passed as type_ids= to query_constraints()</div>
<p>Type IDs are Notion page IDs for rows in the constraint-type catalog. Passing them narrows the constraint query to only constraints that governance rules say apply to those types at that stage.</p>
""",
    "prefetch.mcp_server": """
<div class="dp-header"><span class="dp-icon">ğŸ”Œ</span> Constraint Memory MCP â€” Tool Interface</div>
<table class="er-table">
<thead><tr><th>Tool</th><th>Signature</th><th>Purpose</th></tr></thead>
<tbody>
<tr><td class="pk">constraint_query_types</td><td><code>(stage, event_types)</code></td><td>List/rank constraint types relevant to stage+event</td></tr>
<tr><td class="pk">constraint_query_constraints</td><td><code>(filters, type_ids, tags, sort, limit)</code></td><td>Query with compound server-side filters</td></tr>
<tr><td class="pk">constraint_upsert_constraint</td><td><code>(record, event)</code></td><td>Create or update by UID (idempotent)</td></tr>
<tr><td class="pk">constraint_log_event</td><td><code>(event)</code></td><td>Log lifecycle event: extracted / confirmed / declined</td></tr>
</tbody></table>
<p style="margin-top:6px">All tools are exposed via the <b>constraint-memory</b> MCP server. The extraction LLM agent and the retriever both call these tools â€” the agent via AutoGen tool-calling, the retriever via direct async MCP client calls.</p>
<div class="dp-file">scripts/constraint_mcp_server.py</div>
""",
    "filters": """
<div class="dp-header"><span class="dp-icon">ğŸŸ </span> Phase 3 â€” Notion Query + Compound Filters</div>
<p><code>NotionConstraintStore.query_constraints()</code> translates a <code>ConstraintQuery</code> object into a Notion compound filter and executes it server-side â€” no post-hoc filtering in Python for the main selection.</p>
<p>Filters compose as: <code>AND(scope_filter, status_filter, date_filter, stage_filter, event_type_filter)</code>. Each sub-filter is a Notion property filter. The startup_prefetch pass adds a tags filter and runs separately before the main query.</p>
<p>Click individual filter nodes for exact filter expressions.</p>
""",
    "filters.notion_store": """
<div class="dp-header"><span class="dp-icon">ğŸ“–</span> NotionConstraintStore.query_constraints()</div>
<p>Full entry point. Runs two queries for Stage 1, one for all other stages.</p>
<div class="dp-code"># Stage 1 (CollectConstraints) flow:
# 1. startup_prefetch first-pass
results = query(tags=["startup_prefetch"],
                scope=["profile","datespan"],
                status=["proposed","locked"])
if results:
    return results  # skip main query

# 2. Main query (fallback or non-Stage-1)
results = query(
    scope=["profile","datespan"],
    status=["proposed","locked"],
    start_date__lte=planned_date,
    end_date__gte=planned_date,
    applies_stages__contains=stage,
    applies_event_types__intersects=event_types,
    type_ids=type_ids,
)</div>
<div class="dp-file">src/fateforger/adapters/notion/timeboxing_preferences.py</div>
""",
    "filters.filter_row.date_filter": """
<div class="dp-header"><span class="dp-icon">ğŸ“…</span> Date Range Filter â€” Server-Side</div>
<p>Applied in Notion as two separate property filter conditions, combined with AND:</p>
<div class="dp-code">AND(
  OR(start_date IS EMPTY, start_date &lt;= planned_date),
  OR(end_date   IS EMPTY, end_date   &gt;= planned_date)
)</div>
<p><b>Empty = unbounded:</b> a constraint with no <code>start_date</code> or <code>end_date</code> in Notion must evaluate as always-in-range. Both cells must be empty <em>or</em> within bounds.</p>
<p><b>Example:</b> a constraint valid "this week only" has <code>start_date=Mon, end_date=Sun</code>. A permanent profile preference has both cells empty.</p>
""",
    "filters.filter_row.scope_filter": """
<div class="dp-header"><span class="dp-icon">ğŸ”­</span> Scope Filter</div>
<p>Only <code>profile</code> and <code>datespan</code> constraints are fetched from Notion. Session-scoped constraints live only in SQLite and are merged later by <code>_collect_constraints()</code>.</p>
<div class="dp-code">scope IN ["profile", "datespan"]</div>
<table class="er-table" style="margin-top:8px">
<thead><tr><th>Scope</th><th>Meaning</th><th>Store</th></tr></thead>
<tbody>
<tr><td class="pk">profile</td><td>Permanent user preference, always applies</td><td>Notion</td></tr>
<tr><td class="pk">datespan</td><td>Applies for a specific date range</td><td>Notion</td></tr>
<tr><td class="pk">session</td><td>One-off override for this thread only</td><td>SQLite only</td></tr>
</tbody></table>
""",
    "filters.filter_row.status_filter": """
<div class="dp-header"><span class="dp-icon">âœ…</span> Status Filter</div>
<p>Only active constraints are returned from Notion. Declined constraints are excluded server-side.</p>
<div class="dp-code">status IN ["proposed", "locked"]
# "declined" is excluded server-side</div>
<p><b>Important nuance:</b> a constraint the user declined <em>in the current session</em> may still be <code>proposed</code> in Notion (user hasn't explicitly declined it durably). Those are handled post-retrieval by the <b>suppress step</b> using <code>session.suppressed_durable_uids</code>.</p>
<p>Only when the user explicitly calls "decline" via the Slack UI does the MCP update Notion status to <code>declined</code>.</p>
""",
    "filters.filter_row.stage_filter": """
<div class="dp-header"><span class="dp-icon">ğŸ¯</span> Applies-Stages Filter</div>
<p>Each constraint in Notion declares which planning stages it is relevant to. Only constraints that match the current stage are fetched â€” preventing irrelevant constraints from crowding the LLM context.</p>
<div class="dp-code">applies_stages CONTAINS current_stage_id
# e.g. "CollectConstraints" | "Skeleton" | "Refine"
# Multi-select in Notion â€” each tag is a stage name</div>
<table class="er-table" style="margin-top:8px">
<thead><tr><th>Stage</th><th>What's relevant</th></tr></thead>
<tbody>
<tr><td>CollectConstraints</td><td>All profile defaults / startup prefs</td></tr>
<tr><td>Skeleton</td><td>Time-windows, work blocks, sleep rules</td></tr>
<tr><td>Refine</td><td>Buffer rules, sequencing, capacity limits</td></tr>
<tr><td>ReviewCommit</td><td>Commitment rules, finality constraints</td></tr>
</tbody></table>
""",
    "filters.filter_row.event_filter": """
<div class="dp-header"><span class="dp-icon">ğŸ“‹</span> Event-Type Filter</div>
<p>Each constraint declares which event categories it governs. Only constraints applicable to the event types in the current query plan are fetched.</p>
<div class="dp-code">applies_event_types INTERSECTS query_event_types</div>
<table class="er-table" style="margin-top:8px">
<thead><tr><th>Code</th><th>Event type</th></tr></thead>
<tbody>
<tr><td class="pk">M</td><td>Meeting (fixed-time)</td></tr>
<tr><td class="pk">C</td><td>Commute</td></tr>
<tr><td class="pk">DW</td><td>Deep Work block</td></tr>
<tr><td class="pk">SW</td><td>Shallow Work block</td></tr>
<tr><td class="pk">H</td><td>Habit / ritual</td></tr>
<tr><td class="pk">R</td><td>Rest / sleep</td></tr>
<tr><td class="pk">BU / BG</td><td>Buffer (unstructured / general)</td></tr>
<tr><td class="pk">PR</td><td>Personal / other</td></tr>
</tbody></table>
""",
    "filters.startup_tag": """
<div class="dp-header"><span class="dp-icon">ğŸ·</span> startup_prefetch Tag â€” Stage 1 Fast Path</div>
<p>At Stage 1 (CollectConstraints) <em>only</em>, a first-pass query using a deterministic tag filter runs before the main query.</p>
<div class="dp-flow">
  <div class="dp-flow-step">Query: <code>tags CONTAINS "startup_prefetch"</code> AND <code>scope âˆˆ [profile, datespan]</code> AND <code>status âˆˆ [proposed, locked]</code></div>
  <div class="dp-flow-arrow">â†“ if results found</div>
  <div class="dp-flow-step">Return those results immediately â€” <b>skip main query entirely</b></div>
  <div class="dp-flow-arrow">â†“ if empty (no tagged constraints)</div>
  <div class="dp-flow-step">Fall through to full main query with all stage/event-type filters</div>
</div>
<p><b>Why this exists:</b> the startup_prefetch pass uses a simple tag filter rather than the full compound event-type + stage filter. It's faster and loads the user's always-on "this is who I am" preferences (<em>no early meetings, I exercise at 7am, I don't work after 6pm</em>) onto LLM context before any LLM has seen the session.</p>
<p>Users add the <code>startup_prefetch</code> tag to their permanent profile constraints in Notion to mark them as "always load first."</p>
""",
    "postprocess": """
<div class="dp-header"><span class="dp-icon">ğŸŸ¢</span> Phase 4 â€” Post-Retrieval Processing</div>
<p>After records come back from Notion (via the MCP server), three sequential client-side passes run before the constraints reach the active set.</p>
<ol style="margin-left:18px;font-size:12.5px;line-height:1.9">
  <li><b>Deduplicate</b> â€” startup first-pass and main query may overlap. <code>_dedupe_constraints()</code> keeps the first-seen copy by identity key.</li>
  <li><b>Suppress session overrides</b> â€” if the user's current-session inputs conflict with a loaded default, that default's UID is added to <code>session.suppressed_durable_uids</code> and filtered out. Detected by <code>_normalize_collect_constraints_gate()</code> comparing gate facts to constraint defaults.</li>
  <li><b>days_of_week metadata</b> â€” <em>not</em> filtered; passed through as metadata. The planning LLM must respect it (e.g., "this habit only on MOâ€“FR").</li>
</ol>
<p>These three passes happen inside <code>_collect_constraints()</code> and also incrementally as the prefetch loads stages.</p>
""",
    "postprocess.dedup": """
<div class="dp-header"><span class="dp-icon">â™»ï¸</span> Deduplicate â€” _dedupe_constraints()</div>
<p>The startup first-pass and main query may return the same records. Deduplication uses an identity key (not just UID, since not all records have UIDs).</p>
<div class="dp-code">def _constraint_identity_key(c: Constraint) -> str:
    # Prefer explicit UID if set
    uid = _constraint_uid(c)
    if uid:
        return f"uid:{uid}"
    # Fall back to name + scope + source
    name = (c.name or "").strip().lower()
    scope = (c.scope.value if c.scope else "")
    source = (c.source.value if c.source else "")
    return f"name:{name}:{scope}:{source}"

def _dedupe_constraints(constraints):
    seen, result = set(), []
    for c in constraints:
        key = _constraint_identity_key(c)
        if key not in seen:
            seen.add(key)
            result.append(c)
    return result</div>
<p>Dedup is applied on the combined <code>durable_constraints (all stages) + local_constraints (SQLite)</code> list, so a constraint extracted live in this session and also loaded from Notion won't appear twice.</p>
<div class="dp-file">src/fateforger/agents/timeboxing/agent.py</div>
""",
    "postprocess.suppress": """
<div class="dp-header"><span class="dp-icon">ğŸš«</span> Suppress â€” Session Override Detection</div>
<p>Durable defaults loaded from Notion may conflict with explicit inputs the user provides in the current session. When a conflict is detected, the constraint's UID is added to <code>session.suppressed_durable_uids</code> and hidden for the rest of the session â€” <em>without</em> writing a decline to Notion.</p>
<div class="dp-code"># In _normalize_collect_constraints_gate():
for domain, default_value in defaults["domain_values"].items():
    current_value = facts.get(domain)  # from Stage 1 gate output
    if _facts_conflict_with_default(domain, current_value, default_value):
        for uid in defaults["domain_uids"].get(domain, []):
            session.suppressed_durable_uids.add(uid)
            suppressed_domains.append(domain)

# On next _collect_stage_durable_constraints():
durable = [
    c for c in session.durable_constraints_by_stage[stage]
    if _constraint_uid(c) not in session.suppressed_durable_uids
]</div>
<p><b>Example:</b> Notion has a default "work starts at 9am". User says "I'm starting at 7am today." The gate detects the conflict â†’ suppresses the <code>work-start-9am</code> UID for this session â†’ gate re-derives defaults without it â†’ uses 7am instead.</p>
<p>A summary line is appended to the gate output: <em>"Session override applied for work_window; matching saved defaults were hidden for this session."</em></p>
<div class="dp-file">src/fateforger/agents/timeboxing/agent.py â€” _normalize_collect_constraints_gate()</div>
""",
    "postprocess.dow": """
<div class="dp-header"><span class="dp-icon">ğŸ“†</span> days_of_week Metadata â€” Pass-Through</div>
<p>The <code>days_of_week</code> field on each constraint (<code>MOâ€“SU</code> values) is <em>deliberately not filtered</em> server-side in Notion or post-retrieval in Python. Instead, it is surfaced as metadata in the TOON-encoded constraint block injected into the LLM system prompt.</p>
<p>The planning LLM is responsible for checking: <em>"Does this constraint's <code>days_of_week</code> cover today's day of week before applying it?"</em></p>
<div class="dp-code"># In the skeleton prompt, the constraint row includes:
# constraints[N]{name,necessity,scope,status,source,description}:
# no-sa-su-meetings,must,profile,locked,user,No meetings on weekends
# days_of_week=SA|SU is visible as description metadata

# LLM reasoning: planning date is Monday â†’ SA|SU constraint
# does not apply today â†’ skip it when placing M events</div>
<p><b>Why not filter it?</b> Filtering requires knowing today's day of week at query time. The Notion filter API handles dates well but not day-of-week logic. Pushing this to the LLM is simpler and lets the LLM explain its reasoning in the plan.</p>
""",
    "collect": """
<div class="dp-header"><span class="dp-icon">ğŸ”´</span> _collect_constraints() â€” Assembly Point</div>
<p>Called at the start of every planning stage. Merges durable (Notion) + local (SQLite) constraints, deduplicates, strips suppressed UIDs and DECLINED records.</p>
<div class="dp-code">async def _collect_constraints(self, session: Session):
    # 1. SQLite session-local constraints
    local = await self._constraint_store.list_constraints(
        user_id=session.user_id,
        channel_id=session.channel_id,
        thread_ts=session.thread_ts,
    )

    # 2. Durable constraints (all stages), suppressed filtered out
    durable = [
        c
        for stage_constraints in
            session.durable_constraints_by_stage.values()
        for c in (stage_constraints or [])
        if (uid := _constraint_uid(c)) is None
           or uid not in session.suppressed_durable_uids
    ]

    # 3. Merge, deduplicate, strip DECLINED
    combined = _dedupe_constraints(durable + list(local or []))
    session.active_constraints = [
        c for c in combined
        if c.status != ConstraintStatus.DECLINED
    ]
    return list(session.active_constraints)</div>
<p><b>When it is called:</b></p>
<ul style="font-size:12px;line-height:1.75;margin-left:16px">
  <li>After each background extraction task completes</li>
  <li>After the durable prefetch loads a stage</li>
  <li>Explicitly before Stage 1 gating (after awaiting pending extractions)</li>
  <li>After durable constraint upsert from the extractor</li>
</ul>
<div class="dp-file">src/fateforger/agents/timeboxing/agent.py:3713</div>
""",
    "active": """
<div class="dp-header"><span class="dp-icon">âš¡</span> session.active_constraints â€” Injection into LLM</div>
<p>The final merged, filtered list. Injected into LLM prompts in two different formats depending on context:</p>

<p><b>1. Skeleton/Refine system prompt â€” TOON-encoded table</b></p>
<div class="dp-code"># render_skeleton_draft_system_prompt() builds:
toon_encode(
    name="constraints",
    rows=constraints_rows(context.constraints_snapshot),
    fields=["name","necessity","scope","status","source","description"],
)

# Output in the LLM system prompt:
constraints[3]{name,necessity,scope,status,source,description}:
no-early-meetings,must,profile,locked,user,No meetings before 9am
exercise-morning,should,profile,proposed,user,Exercise block in morning
no-work-after-6,must,profile,locked,user,Stop work by 6pm</div>
<p>The TOON format is compact and token-efficient â€” it encodes structured tables without JSON verbosity. The LLM parses it as a typed record set.</p>

<p style="margin-top:10px"><b>2. Slack stage messages â€” plain text summary</b></p>
<div class="dp-code"># _format_constraints_section(constraints, limit=6):
# â†’ ["No meetings before 9am â€” must",
#    "Exercise in the morning â€” should",
#    "No work after 6pm â€” must"]
# Appended to the stage message as:
# Constraints:
# - No meetings before 9am â€” must
# - Exercise in the morning â€” should
# - No work after 6pm â€” must
# ...and 2 more  (if > 6 constraints)</div>

<p style="margin-top:10px"><b>Stage usage:</b></p>
<table class="er-table">
<thead><tr><th>Stage</th><th>Where constraints appear</th></tr></thead>
<tbody>
<tr><td>CollectConstraints</td><td>Stage 1 gate Slack message (up to 6, plain text)</td></tr>
<tr><td>Skeleton</td><td>TOON block in <code>skeleton_draft_system_prompt.j2</code></td></tr>
<tr><td>Refine</td><td>TOON block in refine system prompt</td></tr>
<tr><td>ReviewCommit</td><td>Plain text summary in user-facing message</td></tr>
</tbody></table>
<div class="dp-file">src/fateforger/agents/timeboxing/prompt_rendering.py Â· agent.py:3000</div>
""",
}

# â”€â”€ Edge tooltip content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EDGE_TOOLTIPS = {
    "user message": """
<b>user message</b><br>
Verbatim Slack text passed as <code>user_utterance</code> in the
<code>ConstraintHandoff</code> JSON payload.<br>
Also includes: <code>planned_date</code>, <code>timezone</code>,
<code>stage_id</code>, optional <code>impacted_event_types</code>
and <code>suggested_tags</code>.
""",
    "proposed constraints": """
<b>proposed constraints â†’ ConstraintBatch</b><br>
Output of the LLM extraction agent.<br>
Contains a list of <code>ConstraintBase</code> objects, each with:<br>
<code>name, description, necessity, status=proposed,<br>
scope, source, tags, selector, days_of_week, payload</code><br>
Status defaults to <code>proposed</code> unless the user
explicitly confirmed/locked it in the same message.
""",
    "upsert (deduped by UID)": """
<b>upsert (deduped by UID)</b><br>
The extractor calls <code>constraint_upsert_constraint(record)</code>
via MCP. Records are keyed by <code>uid</code>.<br>
If a constraint with that UID already exists in Notion,
it is <em>updated in-place</em> (fields merged) rather than
creating a duplicate. New UIDs are created as new Notion pages.
""",
    "session write": """
<b>session write â€” optimistic SQLite copy</b><br>
Written <em>before</em> the Notion upsert completes, so the
Slack UI can show the new constraint immediately.<br>
Key: <code>(user_id, channel_id, thread_ts)</code><br>
This copy is always present; the Notion copy may lag
by up to 20s (extractor timeout).
""",
    "fire async task": """
<b>fire async task â€” non-blocking prefetch</b><br>
<code>_queue_durable_constraint_prefetch()</code> schedules
an asyncio task. The Slack response is not blocked.<br>
Dedup key: <code>user_id:thread_ts:planned_date:stage</code><br>
If <code>durable_constraints_date == planned_date</code> and
the stage is already in <code>durable_constraints_loaded_stages</code>,
the task is skipped entirely.
""",
    "stage != COLLECT": """
<b>stage != COLLECT â€” type_id lookup path</b><br>
For Skeleton / Refine / ReviewCommit, the retriever calls
<code>query_types(stage, event_types)</code> first to get
a ranked list of type IDs from the Notion constraint-type
catalog. These IDs narrow the <code>query_constraints()</code>
call to only semantically relevant types.
""",
    "COLLECT: direct": """
<b>COLLECT: direct â€” no type_id lookup</b><br>
At Stage 1 (CollectConstraints), <code>query_types()</code>
is skipped entirely to avoid extra Notion RPCs on the critical
path. The MCP query uses only scope + status + date filters
(plus the startup_prefetch first-pass tag).
""",
    "Stage 1 first-pass": """
<b>Stage 1 first-pass â€” startup_prefetch tag</b><br>
Before the main query at Stage 1, a fast tag-filter query runs:
<code>tags CONTAINS "startup_prefetch"</code><br>
If it returns results, the main query is skipped.<br>
If empty, the main compound query runs.<br>
Goal: load always-on profile preferences onto LLM context
as fast as possible without the full compound filter cost.
""",
    "durable constraints": """
<b>durable constraints</b><br>
Comes from <code>session.durable_constraints_by_stage[stage]</code>
â€” populated by the background prefetch task.<br>
All stage values are flattened in <code>_collect_constraints()</code>.
Suppressed UIDs (session overrides) are filtered out before merge.
""",
    "session-local constraints": """
<b>session-local constraints</b><br>
Read from SQLite: <code>SELECT * FROM timeboxing_constraints
WHERE thread_ts = :current_thread AND user_id = :user_id</code><br>
Contains constraints extracted live in this conversation,
plus any durable constraints mirrored via
<code>_sync_durable_constraints_to_store()</code>.
""",
}

detail_json = json.dumps(DETAIL_PANELS, ensure_ascii=False)
edge_json = json.dumps(EDGE_TOOLTIPS, ensure_ascii=False)

html = f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Constraint Collection â€” FateForger</title>
<style>
:root {{
  --accent:   #5b7cf6;
  --bg:       #f0f2f7;
  --white:    #ffffff;
  --border:   #e2e4e9;
  --text:     #1a1a2e;
  --muted:    #8890a4;
  --nav-w:    230px;
  --side-w:   380px;
}}
* {{ box-sizing: border-box; margin: 0; padding: 0; }}
body {{
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  display: flex; height: 100vh; overflow: hidden;
  background: var(--bg); color: var(--text);
}}

/* â”€â”€ LEFT NAV â”€â”€ */
#nav {{
  width: var(--nav-w); background: var(--white);
  border-right: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0;
}}
#nav-header {{
  padding: 20px 18px 14px;
  border-bottom: 1px solid var(--border);
}}
#nav-header h1 {{ font-size: 11px; font-weight: 700; letter-spacing: .09em; color: var(--muted); text-transform: uppercase; }}
#nav-header p  {{ font-size: 12px; color: var(--muted); margin-top: 3px; line-height: 1.4; }}

.step-btn {{
  display: flex; align-items: flex-start; gap: 10px;
  padding: 10px 16px; cursor: pointer; border: none;
  background: transparent; text-align: left; width: 100%;
  border-left: 3px solid transparent; transition: background .12s;
}}
.step-btn:hover {{ background: #f3f4f8; }}
.step-btn.active {{ background: #eef1fd; border-left-color: var(--accent); }}

.step-num {{
  width: 20px; height: 20px; border-radius: 50%;
  background: var(--border); color: var(--muted);
  font-size: 10px; font-weight: 700;
  display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; margin-top: 2px; transition: background .12s, color .12s;
}}
.step-btn.active .step-num {{ background: var(--accent); color: #fff; }}
.step-label {{ font-size: 12.5px; line-height: 1.4; color: var(--text); }}
.step-btn.active .step-label {{ font-weight: 600; color: var(--accent); }}

/* â”€â”€ SVG host & sizing â”€â”€ */
#canvas-wrap {{
  flex-grow: 1; position: relative; overflow: hidden; background: #ffffff;
}}
#svg-host {{
  width: 100%; height: 100%; display: block; overflow: hidden; cursor: grab;
}}
#svg-host:active {{ cursor: grabbing; }}
/* Outer D2 wrapper SVG fills the host */
#svg-host > svg {{
  display: block; width: 100%; height: 100%;
}}
/* Inner diagram SVG â€” svgPanZoom targets this */
#svg-host > svg > svg {{
  display: block;
}}

#toolbar {{
  position: absolute; bottom: 14px; right: 14px; z-index: 10;
  display: flex; gap: 5px;
}}
.tb-btn {{
  background: var(--white); border: 1px solid var(--border);
  border-radius: 6px; padding: 6px 13px; font-size: 13px;
  cursor: pointer; color: var(--text);
  box-shadow: 0 1px 4px rgba(0,0,0,.07); transition: background .1s;
}}
.tb-btn:hover {{ background: #f3f4f8; }}

/* â”€â”€ RIGHT SIDEBAR â”€â”€ */
#sidebar {{
  width: var(--side-w); background: var(--white);
  border-left: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0; overflow: hidden;
}}
#sidebar-inner {{
  padding: 26px 22px; overflow-y: auto; flex-grow: 1;
}}
.step-tag {{
  display: inline-block; font-size: 10.5px; font-weight: 700;
  letter-spacing: .07em; text-transform: uppercase;
  color: var(--accent); background: #eef1fd;
  border-radius: 4px; padding: 2px 8px; margin-bottom: 10px;
}}
#step-title {{
  font-size: 17px; font-weight: 700; line-height: 1.3;
  margin-bottom: 13px; color: var(--text);
}}
#step-body p {{
  font-size: 13.5px; line-height: 1.7; color: #444; margin-bottom: 11px;
}}
#step-body b  {{ color: var(--text); }}
#step-body code {{
  background: #f3f4f8; border: 1px solid var(--border);
  border-radius: 3px; padding: 1px 5px;
  font-size: 11.5px; font-family: "SF Mono", "Fira Code", monospace;
}}
.fact-list {{
  list-style: none; display: flex; flex-direction: column;
  gap: 9px; margin-bottom: 13px;
}}
.fact-list li {{
  position: relative;
  padding-left: 18px;
  font-size: 13px; line-height: 1.6; color: #333;
  word-break: break-word;
}}
.fact-list li::before {{
  content: "\u2192"; color: var(--accent); font-weight: 700;
  position: absolute; left: 0; top: 1px;
}}
.callout {{
  background: #fffbeb; border: 1px solid #fde68a;
  border-radius: 8px; padding: 10px 14px;
  font-size: 12.5px; line-height: 1.6; color: #78350f; margin-top: 6px;
}}
.callout.info {{ background: #eff6ff; border-color: #bfdbfe; color: #1e40af; }}

/* footer nav */
#sidebar-footer {{
  padding: 12px 20px; border-top: 1px solid var(--border);
  display: flex; gap: 8px;
}}
.nav-btn {{
  flex: 1; padding: 8px; border: 1px solid var(--border);
  border-radius: 7px; background: var(--white); font-size: 12px;
  cursor: pointer; color: var(--text); transition: background .1s, border-color .1s;
}}
.nav-btn:hover {{ background: #f3f4f8; border-color: var(--accent); }}
.nav-btn:disabled {{ opacity: .3; cursor: default; pointer-events: none; }}

/* â”€â”€ SVG node + edge visibility â”€â”€ */
.d2-node, .d2-edge {{ transition: opacity .25s ease; }}
/* Lit nodes: bold vivid fill so they POP against white canvas */
.d2-node.lit rect,
.d2-node.lit path,
.d2-node.lit ellipse,
.d2-node.lit polygon {{
  fill-opacity: 1 !important;
  stroke: #1d4ed8 !important;
  stroke-width: 3 !important;
  filter: drop-shadow(0 0 10px rgba(59,130,246,.28));
}}
/* Dark text with white halo for readability on any fill */
.d2-node.lit text {{
  fill: #0a0f25 !important;
  font-weight: 700;
  stroke: rgba(255,255,255,.92);
  stroke-width: .95px;
  paint-order: stroke fill;
}}
/* Lit edges: bold indigo */
.d2-edge.lit path {{
  stroke: #1d4ed8 !important;
  stroke-width: 2.5 !important;
}}
/* Focus mode: hidden elements collapse completely */
.focus-mode .d2-node.dimmed,
.focus-mode .d2-edge.dimmed {{
  visibility: hidden;
  pointer-events: none;
}}

/* â”€â”€ Detail Drawer â”€â”€ */
#detail-drawer {{
  position: absolute;
  bottom: 0; left: 0; right: 0;
  max-height: 48%;
  background: var(--white);
  border-top: 2px solid var(--accent);
  border-radius: 12px 12px 0 0;
  box-shadow: 0 -6px 32px rgba(0,0,0,.13);
  transform: translateY(100%);
  transition: transform .28s cubic-bezier(.4,0,.2,1);
  z-index: 20;
  display: flex; flex-direction: column; overflow: hidden;
}}
#detail-drawer.open {{ transform: translateY(0); }}
#drawer-handle {{
  width: 36px; height: 4px; background: var(--border);
  border-radius: 2px; margin: 8px auto 0;
  cursor: grab; flex-shrink: 0;
}}
#drawer-header {{
  display: flex; align-items: center;
  padding: 6px 16px 10px; flex-shrink: 0;
  border-bottom: 1px solid var(--border);
}}
#drawer-node-id {{
  font-size: 11px; color: var(--muted);
  font-family: "SF Mono", "Fira Code", monospace;
  background: #f3f4f8; border-radius: 4px;
  padding: 2px 8px; margin-right: 10px;
  flex-shrink: 0;
}}
#drawer-close {{
  margin-left: auto; background: none; border: none;
  cursor: pointer; font-size: 19px; color: var(--muted);
  padding: 0 4px; line-height: 1;
}}
#drawer-close:hover {{ color: var(--text); }}
#drawer-body {{
  overflow-y: auto; padding: 14px 18px;
  flex-grow: 1;
  font-size: 12.5px; line-height: 1.65; color: #333;
}}

/* Detail panel internals */
.dp-header {{
  font-size: 13px; font-weight: 700;
  margin-bottom: 10px; color: var(--text);
  display: flex; align-items: center; gap: 7px;
}}
.dp-icon {{ font-size: 16px; }}
.dp-file {{
  margin-top: 10px;
  font-size: 11px; font-family: "SF Mono", monospace;
  color: var(--muted); background: #f3f4f8;
  border-radius: 4px; padding: 4px 8px;
  word-break: break-all;
}}
.dp-code {{
  background: #1a1a2e; color: #c9d1e8;
  border-radius: 7px; padding: 10px 14px;
  font-size: 11.5px; font-family: "SF Mono", "Fira Code", monospace;
  line-height: 1.65; margin: 8px 0;
  white-space: pre; overflow-x: auto;
}}
.dp-flow {{
  display: flex; flex-direction: column;
  gap: 2px; margin: 8px 0;
}}
.dp-flow-step {{
  background: #f3f4f8; border-radius: 6px;
  padding: 7px 12px; font-size: 12px;
}}
.dp-flow-arrow {{
  padding: 0 14px; font-size: 13px; color: var(--accent);
  font-style: normal;
}}
.dp-body p {{ margin-bottom: 8px; }}

/* ER table */
.er-table {{
  width: 100%; border-collapse: collapse;
  font-size: 11.5px; margin: 8px 0;
}}
.er-table th {{
  background: #f3f4f8; text-align: left;
  padding: 5px 9px; font-size: 11px; font-weight: 700;
  color: var(--muted); text-transform: uppercase;
  letter-spacing: .04em; border-bottom: 1px solid var(--border);
}}
.er-table td {{
  padding: 5px 9px; border-bottom: 1px solid #f0f2f7;
  vertical-align: top;
}}
.er-table tr:last-child td {{ border-bottom: none; }}
.er-table td.pk {{
  font-family: "SF Mono", monospace; font-size: 11px;
  color: var(--accent); font-weight: 600;
}}
.er-table code {{
  background: #eef1fd; border-radius: 3px;
  padding: 1px 4px; font-size: 10.5px;
  font-family: "SF Mono", monospace; color: var(--accent);
}}

/* â”€â”€ Edge tooltip â”€â”€ */
#edge-tooltip {{
  position: fixed;
  background: #1a1a2e; color: #e2e8f0;
  border-radius: 8px; padding: 9px 13px;
  font-size: 12px; max-width: 270px; line-height: 1.55;
  pointer-events: none;
  z-index: 200;
  opacity: 0; transition: opacity .15s;
  box-shadow: 0 4px 18px rgba(0,0,0,.25);
}}
#edge-tooltip.visible {{ opacity: 1; }}
#edge-tooltip b {{ color: #a5b4fc; }}
#edge-tooltip code {{
  background: rgba(255,255,255,.12);
  border-radius: 3px; padding: 1px 5px;
  font-family: "SF Mono", monospace; font-size: 10.5px;
}}
</style>
</head>
<body>

<!-- LEFT NAV -->
<nav id="nav">
  <div id="nav-header">
    <h1>FateForger</h1>
    <p>Constraint collection<br>walkthrough</p>
  </div>
  <button class="step-btn active" data-step="0" onclick="goStep(0,this)">
    <span class="step-num">â˜…</span><span class="step-label">Full flow</span>
  </button>
  <button class="step-btn" data-step="1" onclick="goStep(1,this)">
    <span class="step-num">1</span><span class="step-label">The two constraint stores</span>
  </button>
  <button class="step-btn" data-step="2" onclick="goStep(2,this)">
    <span class="step-num">2</span><span class="step-label">Live extraction</span>
  </button>
  <button class="step-btn" data-step="3" onclick="goStep(3,this)">
    <span class="step-num">3</span><span class="step-label">Prefetch trigger</span>
  </button>
  <button class="step-btn" data-step="4" onclick="goStep(4,this)">
    <span class="step-num">4</span><span class="step-label">Building the query plan</span>
  </button>
  <button class="step-btn" data-step="5" onclick="goStep(5,this)">
    <span class="step-num">5</span><span class="step-label">Server-side Notion filters</span>
  </button>
  <button class="step-btn" data-step="6" onclick="goStep(6,this)">
    <span class="step-num">6</span><span class="step-label">startup_prefetch tag</span>
  </button>
  <button class="step-btn" data-step="7" onclick="goStep(7,this)">
    <span class="step-num">7</span><span class="step-label">Post-retrieval processing</span>
  </button>
  <button class="step-btn" data-step="8" onclick="goStep(8,this)">
    <span class="step-num">8</span><span class="step-label">Merge into active_constraints</span>
  </button>
</nav>

<!-- CENTRE: inline SVG -->
<div id="canvas-wrap">
  <div id="svg-host">{svg_raw}</div>
  <!-- Detail drawer (slides up from bottom of canvas on node click) -->
  <div id="detail-drawer">
    <div id="drawer-handle"></div>
    <div id="drawer-header">
      <span id="drawer-node-id"></span>
      <button id="drawer-close" onclick="hideDetail()" title="Close">âœ•</button>
    </div>
    <div id="drawer-body"></div>
  </div>
  <div id="toolbar">
    <button class="tb-btn" id="btn-focus" onclick="toggleFocus()" title="Toggle between Focus (only active nodes) and Context (everything, with highlights)">â— Focus</button>
    <button class="tb-btn" id="btn-fit" onclick="resetOverview()">Fit</button>
    <button class="tb-btn" id="btn-zoom-in" onclick="pz&&pz.zoomIn()">ï¼‹</button>
    <button class="tb-btn" id="btn-zoom-out" onclick="pz&&pz.zoomOut()">ï¼</button>
  </div>
</div>

<!-- Edge tooltip (floats near cursor on hover) -->
<div id="edge-tooltip"></div>

<!-- RIGHT SIDEBAR -->
<aside id="sidebar">
  <div id="sidebar-inner">
    <span class="step-tag" id="step-tag"></span>
    <h2 id="step-title"></h2>
    <div id="step-body"></div>
  </div>
  <div id="sidebar-footer">
    <button class="nav-btn" id="btn-prev" onclick="goStep(curStep-1,null)">â† Prev</button>
    <button class="nav-btn" id="btn-next" onclick="goStep(curStep+1,null)">Next â†’</button>
  </div>
</aside>

<!-- svg-pan-zoom inlined -->
<script>{panzoom_js}</script>

<script type="module">
import {{ D2StoryViewer }} from "./javascripts/d2-viewer/index.js";

const STEPS        = {steps_json};
const NODE_IDS     = {nodes_json};
const DETAIL_PANELS = {detail_json};
const EDGE_TOOLTIPS = {edge_json};
const viewer = new D2StoryViewer({{
  steps: STEPS,
  nodeIds: NODE_IDS,
  detailPanels: DETAIL_PANELS,
  edgeTooltips: EDGE_TOOLTIPS,
  selectors: {{
    canvasWrap: "#canvas-wrap",
    svgHost: "#svg-host",
    targetSvg: "#svg-host > svg",
    stepButtons: ".step-btn",
    stepTag: "#step-tag",
    stepTitle: "#step-title",
    stepBody: "#step-body",
    prevBtn: "#btn-prev",
    nextBtn: "#btn-next",
    focusBtn: "#btn-focus",
    fitBtn: "#btn-fit",
    zoomInBtn: "#btn-zoom-in",
    zoomOutBtn: "#btn-zoom-out",
    detailDrawer: "#detail-drawer",
    drawerNodeId: "#drawer-node-id",
    drawerBody: "#drawer-body",
    edgeTooltip: "#edge-tooltip",
  }},
  svgPanZoom: window.svgPanZoom,
  exposeGlobals: true,
  autoBindControls: false,
}});
viewer.init();
</script>
</body>
</html>"""

out = HERE / "constraint_flow.html"
out.write_text(html, encoding="utf-8")
print(f"Written {len(html):,} bytes â†’ {out}")
print("Open docs/constraint_flow.html in any browser â€” no server needed.")
